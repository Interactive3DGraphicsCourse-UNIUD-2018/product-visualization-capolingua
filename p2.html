<html>

<head>
    <title>Load OBJ File</title>
    <style>
        body {
            font-family: Monospace;
            background-color: #f0f0f0;
            margin: 0px;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
        }
    </style>
    <script src="lib/three.min.js"></script>
    <script src="lib/stats.min.js"></script>
    <script src="lib/OBJLoader.js"></script>
</head>

<body>
    <script type="text/x-glsl" id="vertex">
        varying vec3 vNormal;
		varying vec3 vPosition;
		varying vec2 uVv;

		void main() {
			vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
			vPosition = vPos.xyz;
			vNormal = normalMatrix * normal;
			uVv = uv;
			gl_Position = projectionMatrix * vPos;
		}
        </script>

    <script type="text/x-glsl" id="vertex">
        varying vec3 vNormal;
		varying vec3 vPosition;
		varying vec2 uVv;

		void main() {
			vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
			vPosition = vPos.xyz;
			vNormal = normalMatrix * normal;
			uVv = uv;
			gl_Position = projectionMatrix * vPos;
		}
		</script>

    <script type="text/x-glsl" id="fragment">
        varying vec3 vNormal;
			varying vec3 vPosition;
			varying vec2 uVv;
			uniform vec3 pointLightPosition; // in world space
            uniform vec3 clight;
            uniform sampler2D normalMap;
			uniform sampler2D diffuseMap;
			uniform vec2 textureRepeat;
			const float PI = 3.14159;

			vec3 cdiff;
			vec3 cspec;
			float roughness=0.68;

			vec3 FSchlick(float lDoth) {
				return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
			}

			float DGGX(float nDoth, float alpha) {
				float alpha2 = alpha*alpha;
				float d = nDoth*nDoth*(alpha2-1.0)+1.0;
				return (  alpha2 / (PI*d*d));
			}

			float G1(float dotProduct, float k) {
				return (dotProduct / (dotProduct*(1.0-k) + k) );
			}

			float GSmith(float nDotv, float nDotl) {
					float k = roughness*roughness;
					return G1(nDotl,k)*G1(nDotv,k);
			}

			void main() {
				vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 );
				vec3 l = normalize(lPosition.xyz - vPosition.xyz);
				vec3 n = normalize( vNormal );  // interpolation destroys normalization, so we have to normalize
				vec3 v = normalize( -vPosition);
				vec3 h = normalize( v + l);
				// small quantity to prevent divisions by 0
				float nDotl = max(dot( n, l ),0.000001);
				float lDoth = max(dot( l, h ),0.000001);
				float nDoth = max(dot( n, h ),0.000001);
				float vDoth = max(dot( v, h ),0.000001);
				float nDotv = max(dot( n, v ),0.000001);

				cdiff = texture2D( diffuseMap, uVv*textureRepeat ).rgb;
				// texture in sRGB, linearize
				cdiff = pow( cdiff, vec3(2.2));
				cspec = texture2D( specularMap, uVv*textureRepeat ).rgb;
				// texture in sRGB, linearize
				cspec = pow( cspec, vec3(2.2));

				vec3 fresnel = FSchlick(lDoth);
				vec3 BRDF = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl)*DGGX(nDoth,roughness*roughness)/
					(4.0*nDotl*nDotv);
				vec3 outRadiance = PI* clight * nDotl * BRDF;
				// gamma encode the final value
				gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
			}
		</script>

    <script>
        var scene, renderer, camera, stats;

        function Start() {

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0xf0f0f0);
            document.body.appendChild(renderer.domElement);

            var lightParameters = {
                red: 1.0,
                green: 1.0,
                blue: 1.0,
                intensity: 1.0,
            }

            var textureParameters = {
                material: "Blue",
                repeatS: 1.0,
                repeatT: 1.0,
            }
            var diffuseMap = loadTexture("./data/texture/Texture.jpg");
            var normalMap = loadTexture("./data/texture/Normal.jpg");

            var uniforms = {
                diffuseMap: {
                    type: "t",
                    value: diffuseMap
                },
                normalMap: {
                    type: "t",
                    value: normalMap
                },

                normalScale: {
                    type: "v2",
                    value: new THREE.Vector2(1, 1)
                },
                pointLightPosition: {
                    type: "v3",
                    value: new THREE.Vector3()
                },
                clight: {
                    type: "v3",
                    value: new THREE.Vector3()
                },
                roughness: {
                    type: "f",
                    value: 0.7
                },
                textureRepeat: {
                    type: "v2",
                    value: new THREE.Vector2(1, 1)
                }
            };
            vs = document.getElementById("vertex").textContent;
            fs = document.getElementById("fragment").textContent;
            var material = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: vs,
                fragmentShader: fs
            });

            // instantiate a loader
            var loader = new THREE.OBJLoader();
            // load a resource
            loader.load("./data/model/shoe.obj", function (group) {
                geometry = group.children[0].geometry;
                geometry.center();
                mesh = new THREE.Mesh(geometry, material);
                mesh.scale.set(28, 28, 28);
                scene.add(mesh);
            });

            function loadTexture(file) {
                var texture = new THREE.TextureLoader().load(file, function (texture) {

                    texture.minFilter = THREE.LinearMipMapLinearFilter;
                    texture.anisotropy = renderer.getMaxAnisotropy();
                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                    texture.offset.set(0, 0);
                    texture.needsUpdate = true;
                    render();
                })
                return texture;
            }

            stats = new Stats();
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.top = '0px';
            document.body.appendChild(stats.domElement);

            camera.position.z = 20;
            camera.position.y = 5;

        }

        function render() {
            requestAnimationFrame(render);

            stats.update();

            renderer.render(scene, camera);
        }

        Start();
        render();
    </script>
</body>

</html>